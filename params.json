{"name":"Ios-不调用dealloc","tagline":"技术博客","body":"在一个项目中，如果ViewController使用完成之后，发现这个东东并没有释放掉，dealloc方法不走，看着那个内存蹭蹭的网上增，就跟自己的火气一样。相信大家都知道如何去释放一个不用的ViewController，但是还是有些其他因素限制了内存释放。\r\n首先，如果你创建了一个VController,使用它却没释放它，那这个VC肯定存在,那dealloc指定不调用，那么你创建的类就会内存泄露\r\n    textViewController * text = [[textViewController alloc] init];\r\n    [self.navigationController pushViewController:text animated:YES];\r\n    //[text release];\r\n\r\n然后，如果你的VC中有NSTimer，那么就要注意了，因为当你\r\n[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(updateTime:) userInfo:nil repeats:YES];\r\n\r\n时，这个 target:self 就增加了VC的RetarnCountr如果你不将这个timer invalidate，就别想调用dealloc。\r\n\r\n再然后，一个比较隐蔽的因素，你反过头去找找看，跟这个类有关的代理，嗯，对是代理，有没有强引用的属性啊？对，比如一个代理的delegate应该是 assign 的现在是retain，(╯‵□′)╯︵┻━┻，就是这个，它会影响你不让你调用dealloc，不信，就试试吧。\r\n\r\n最后，如果以上都没有问题的话，那么，真问题就来了。我就遇到了这种情况，在使用ASI进行网络请求的时候，因为需求原因，我使用属性将名为 ASIFormDataRequest 的NSOperation 标记住了，就将上面的问题找了又找，就是不行，最后是将那个标记的属性置为 nil 才解决了这个不调用 dealloc 的这个蛋疼问题。所以，如果你遇到了比较隐蔽的原因，那就去找找你自己控制不了的因素，就像这个第三方。如果你不了解它的运行机制，那就一定要注意这个库对你程序的影响。嗯，善用XXX.delegate = self;\r\n\r\nPS:dealloc中的释放也是有顺序的，就好比创建时，先父类，再子类，释放的时候反过来，不然有几率会crash，至于原因。 ———————— 看了一个帖子，上面说：子类是父类的继承，比较NB，以至于要杀死他们的时候应该先干掉比较牛B的子类。    看完后我就记住了。很有意思~\r\n\r\nself拥有block 时 block中的所有关于self的均用weak ，但是block中调用的方法中的self不用weak；\r\nif(!self.checkPuppetUser){\r\n        self.checkPuppetUser = [[SouFunCheckPuppetUser alloc] init];\r\n    }\r\n    __weak typeof(self) weakSelf = self;\r\n    self.myScrollView.userInteractionEnabled = NO;//防止在验证时与界面交互\r\n    [self.view showActivityViewAtCenter];\r\n    [self.checkPuppetUser CheckPhoneNumRequestSuccess:^(NSString *checkSuccess) {\r\n        weakSelf.myScrollView.userInteractionEnabled = YES;//可以与界面交互\r\n        [weakSelf.view hideActivityViewAtCenter];\r\n        weakSelf.isBinding = YES;\r\n    } Error:^(NSString *checkError) {\r\n        weakSelf.myScrollView.userInteractionEnabled = YES;//可以与界面交互\r\n        [weakSelf.view hideActivityViewAtCenter];\r\n        //未绑定手机号 需要绑定手机号\r\n        if (IOS8DEVICE){\r\n            [UtilitiesCreatCommentView creatAlertView:@\"\" message:@\"绑定手机号才能写点评\" cancel:@\"取消\" sure:@\"绑定\" handler:^(NSString *type) {\r\n                [weakSelf TheAlertViewResponTobindiphone:type];\r\n            } delegate:weakSelf otherButtonTitles:nil, nil];\r\n        }else{\r\n            UIAlertView * newAlertView = [[UIAlertView alloc] initWithTitle:@\"\" message:@\"绑定手机号才能写点评\" delegate:weakSelf cancelButtonTitle:@\"取消\" otherButtonTitles:@\"绑定\", nil];\r\n            newAlertView.delegate = weakSelf;\r\n            newAlertView.tag = 100012;\r\n            [newAlertView show];\r\n        }\r\n    }];\r\n\r\n还有出现循环引用的是 参数的传递比如：\r\n- (instancetype)initWithFrame:(CGRect)frame superViewcontroller:(UIViewController *)superViewcontroller\r\n{\r\n    _superViewcontroller = superViewcontroller;\r\n    self = [self initWithFrame:frame];\r\n\r\n    return self;\r\n}\r\n如果返回的实例变量是一个类的属性，而这个类通过实例变量的初始化传递进来，进而赋值给一个strong的属性，那就发生了循环引用的问题\r\n\r\n另外：\r\n1 如果该类中的属性或者实例变量要引用该类，也要使用weak属性；因为先释放属性再释放本类","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}